Memory Debugging Warmup
-----------------------
Q1. What does the yellow background for a test case indicate in the SimpleTest result window?
A1. The yellow background on test cases indicates that a memory leak has occured.

Q2. What is the observed consequence of a test that uses `delete` on a memory address that has already been deallocated?
A2. The program immediately crashes showing the symptoms of a memory error more fatal than just a memory leak.

Q3. On your system, what is the observed consequence of `badDeallocate`? Under what circumstances (if any) did the buggy code trigger an error or crash?
A3. The low exposure badDeallocate test runs correctly and does not display any errors or memory leaks.
    The badDeallocate test with more exposure turns yellow and mentions that 1,678 objects were leaked.
    It does not cause the program to crash in any case.

Q4. How is a segmentation fault presented on your system?
A4. On my system which runs windows, a segmentation fault causes a "text-like" message to appear detailing that
    SIGSEGV has occured. Once I close this pop-up, the application output has a similar output message detailing
    that "a segmentation fault (SIGSEGV) occurred during program execution". The program crashes and does not
    run beyond this point. Under the debugger, the same symptoms occur except that the yellow arrow points to the
    line which caused the segmentation fault to occur.

Labyrinth
---------
Q5. What is a different legal path through the example labyrinth that gathers all three needed items?
A5. WNNEWSSEESNWSWWN


Sorting Linked Lists
---------------------
Q6. If the `deallocateList` utility function were implemented recursively, give a rough estimate of the maximum length list it could successfully handle. What would be the observed result from attempting to deallocate a list longer than this maximum?
A6. The maximum length linked list that my laptop would be able to handle would be 4323 nodes long. My laptop can handle up to 4323 stack frames before showing symptoms of a stack overflow error.
    If the deallocateList was implemented recursively on a list with over 4323 nodes, then my laptop would go into a stack overflow error and not be able to properly deallocate the list.

Q7. The prototype for the sort function takes a `ListNode*` by reference. Explain why the pointer itself needs to be passed by reference and what the consequence would be if it were not.
A7. The QuickSort function has the starting node called ListNode* passed in by reference since QuickSort is a void function. In order to reorder the nodes in QuickSort and return the sorted
    result, the linked list must be passed by reference. If it were to be passed by value, then the linked list would be copied with each recursive call, and it would not get updated throughout the
    sorting process. Therefore, it is much more efficient and creates less opportunities for bugs to pass in the linked list by reference.

Q8. Run time trials and provide your results that confirm that QuickSort is O(NlogN) . Verify the runtime degrades to O(N^2) on inputs constructed to trigger the worst case behavior.
A8.
    QuickSort time trial:

        n    |   time (seconds)
     --------|-----------------
      500000 |   0.014
     1000000 |   0.028
     2000000 |   0.053
     4000000 |   0.114

    QuickSort worst case time trial:

        n    |   time (seconds)
     --------|-----------------
        1000 |   0.003
        2000 |   0.009
        4000 |   0.034
        8000 |   0.137

    The typical case of O(NlogN) is shown in the first runtime chart. The time nearly doubles
    each time the value of n doubles, showing an almost linear relationship. The worst case
    scenario for QuickSort has a time that quadruples each time the value of n doubles,
    showing the O(N^2) runtime.

Q9. Run the provided timing trials that compare your linked list QuickSort to a Vector sort on the same sequence and report the results. Who wins and why?
A9. QuickSort time trial data:

        n    |   time (seconds)
     --------|-----------------
        5000 |   0.001
       10000 |   0.002
       20000 |   0.004
       40000 |   0.008

    Vector time trial data:

        n    |   time (seconds)
     --------|-----------------
        5000 |   0.009
       10000 |   0.015
       20000 |   0.032
       40000 |   0.069

     The QuickSort time trial won compared to the vector sort function. However, the times
     for QuickSort and the vector's sort function both seem to grow similarly as the value
     of n doubles. This happens because the QuickSort function has an average runtime of
     O(NlogN), best case of O(logN), and worst case of O(N^2). The vector sort function
     also has a runtime of O(NlogN), but it is less efficient making it slower than QuickSort.
     Sorting includes adding elements in particular spots, swapping, inserting elements, etc.
     All of these operations are more extensive and require more work on a vector than a
     linked list.
